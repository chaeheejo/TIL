1초당 1억번까지는 안전한 시간이다.

## DAT

DAT : Direct Access Table

배열의 인덱스에 의미를 부여한 것 (HashMap의 배열화 버전)

1000만 개의 데이터를 저장하고, 아이디를 검색하려 할 때 어떻게 하면 효과적일 수 있을까?

배열 1000만 개를 만들고, 각 인덱스를 아이디 값으로 지정하면 array[ID] 만 읽어 들이면 해당 아이디가 지정되었는지 아니었는지 쉽게 확인할 수 있음

12312312… 어떤 숫자가 몇 번씩 나왔는가?

10개의 배열을 만들어서 각 자릿수의 수를 index로 활용해 접근하면 보다 빠르게 해결 가능 → array[NUM] = 해당 숫자가 나온 횟수

## Graph

graph를 저장하는 방법 : 인접 행렬, 인접 리스트

1. 인접 행렬 : DAT[a][b] = 1
    
    장점) 연결 유무 바로 접근 가능
    
    단점) 메모리 낭비 - 노드 하나 당 무조건 각각의 노드와 연결되어 있어야 함
    
2. 인접 리스트 : vector<int> graph[nodeNum]
    
    장점) 노드 당 연결된 정보만 탐색할 수 있음
    
    단점) 노드가 연결되어 있는지 하나하나 확인해봐야 함
    

## BFS - 너비 우선 탐색

알고리즘 정의 : 루트 노드에서 시작해 인접한 노드를 먼저 탐색하는 기법

구현 : 큐와 visited 배열을 사용해 구현

문제 유형 : 최단 경로

## DFS - 깊이 우선 탐색

알고리즘 정의 : 루트 노드에서 시작해 리프 노드에 도달할 때까지 탐색하는 기법

구현 : 재귀를 사용해 구현, 탈출 조건은 backtracking

문제 유형 : 순열, 조합 등 모든 경우를 탐색해야 하는 완전 탐색 문제 or 깊이가 정해져 있는 그래프 탐색

## Backtracking

알고리즘 정의 : 퇴각 검색, 현재 상태가 유망하지 않으면 다음으로 진행하지 않고 종료

구현 : DFS 알고리즘과 함께 사용

## Sort, Priority Queue

정렬 : 배열의 모든 요소를 줄 세움 

단점) 모든 요소를 정렬하는 데 드는 시간 O(N logN)

우선순위 큐 : 최상위 노드에 반환하는 시간 O(1) and 노드를 정렬하는 시간 O(logN)

단점) 모든 요소는 줄 세우지 않아 pop and sort를 반복해야 함

## Heap

알고리즘 정의 : 완전 이진 트리 형태로 우선순위 큐를 위해 고안된 자료구조
